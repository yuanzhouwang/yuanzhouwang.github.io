---
title: "Lab 4 - Merging Data in R"
output: html_document
---
> In today's lab you will learn:

> 1) The `dplyr` pipe, as well as functions `filter()` and `mutate()`.
> 2) The various types of `merge()` - inner, outer, left, right.
> 3) Diagnostic functions for checking merged data.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide', warning = FALSE, message = FALSE)
```

# Data & Variables

We’ll use the `gapminder` package. If needed, install it with `install.packages("gapminder")`.

**Gapminder** contains columns:

- `country`: country name
- `continent`: continent
- `year`: observation year
- `lifeExp`: life expectancy at birth, in years
- `pop`: population
- `gdpPercap`: GDP per capita (inflation-adjusted, USD)

Review: What is the type of each variable?

We will also create two new variables.

# Load Packages

```{r}
# install.packages("gapminder") # uncomment if not installed
library(dplyr)
library(gapminder)
df <- gapminder
```

# The `dplyr` pipe (`%>%`)

The dplyr pipe (`%>%`, and in modern R also the base pipe `|>`) lets you express a sequence of data transformations from left to right, reading like a sentence. Instead of nesting function calls, you “pipe” the output of one step into the next, which keeps code legible and encourages small, composable operations.

Given some function `function1(input1)` returns `output 1`, and `function2(input2)`,
`function1(input1) %>% function2()` is equivalent to `function2(output1)`. If `function2(input2a,input2b)` has multiple arguments, you can indicate the argument to replace with `.`. Otherwise, the pipe will assume the first argument is taking the previous input.

Let's try with some basic examples. For the vector `lifeExp`, please provide script to compute the square of the sum and the sum of the squares using the pipe.

```{r}
# Square of sum
# [Your code here]

# Sum of squares
# [Your code here]


```


# Filter and Mutate

`filter(condition)` keeps rows that satisfy logical condition `condition==TRUE`. These conditions use standard comparison operators (`==`, `>`, `<=`), logical connectors (`&`, `|`), and helpers like `%in%` for set membership and `is.na()` for missingness.

- `&` (AND): `TRUE` if and only if both conditions are `TRUE`. What does `filter(continent == "Asia" & lifeExp > 70)` do?

- `|` (OR): at least one condition must be `TRUE`. What does `filter(continent == "Asia" | continent == "Europe")` do?

- `%in%` (set membership): tests whether a value is in a vector of allowed values (cleaner than chaining many `OR`s). What does `filter(continent %in% c("Asia", "Europe"))` do?

- `is.na()` (missingness): returns TRUE for missing values; combine with ! (NOT) to exclude missingness.
What does `filter(!is.na(lifeExp))` do?


`mutate()` creates or modifies columns, computing values rowwise in a vectorized way. The syntax is `mutate(new_or_modified = function(column1, column2, etc.))` You can build on columns created earlier in the same `mutate()` call, overwrite existing columns, and use helpers like `if_else()`, `case_when()`, or `across()` for many-column operations. Here we focus only on `if_else()`.

We want to keep a single year (**2007**) and three continents (**Africa, Europe, Asia**), then create `gdp_total`, the total GDP of the country, and `rich`, a numeric binary variable that is 1 for countries with GDP per capita over 20,000 and 0 otherwise.

```{r}
# Create gdp_total, rich
# [Your code here]

```

Review: check the following diagnostics:
- How many rows are in `df` now?
- How many unique countries are represented?
- What is the year range?
- How many unique continents are represented?

```{r}
# [Your code here]
```