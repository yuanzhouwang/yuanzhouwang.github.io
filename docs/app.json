[{"name":"app.R","content":"# app.R\r\nlibrary(shiny)\r\nlibrary(ggplot2)\r\n\r\nui <- fluidPage(\r\n  titlePanel(\"Q(P) model with g(Q), ρ(Q), and f(B)\"),\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      numericInput(\"N\", \"N (population cap)\", value = 50, min = 1, step = 1),\r\n      numericInput(\"T\", \"T (threshold)\", value = 50, min = 0, step = 1),\r\n      numericInput(\"d\", \"d (baseline)\", value = 0, step = 0.1),\r\n      \r\n      radioButtons(\"rhoType\", \"ρ(Q) form\",\r\n                   c(\"Olsonian: ρ(Q) = Q / g(Q)\" = \"olsonian\",\r\n                     \"Lumpy: ρ(Q) = (T - Q) / g(Q)\" = \"lumpy\")),\r\n      \r\n      radioButtons(\"gType\", \"g(Q) form (auto-normalized)\",\r\n                   c(\"Logistic\" = \"logistic\",\r\n                     \"Exponential\" = \"exponential\",\r\n                     \"Linear\" = \"linear\",\r\n                     \"Superlinear\" = \"superlinear\")),\r\n      \r\n      numericInput(\"eps\", \"Calibrate g(Q_anchor) = 1 - ε  (ε)\",\r\n                  min = 1e-4, max = 0.1, value = 0.01, step = 1e-4),\r\n      \r\n      conditionalPanel(\r\n        condition = \"input.gType == 'logistic'\",\r\n        numericInput(\"g0\", \"Set g(0) = g0 (logistic only)\",\r\n                    min = 1e-6, max = 0.49, value = 0.05, step = 1e-3)\r\n      ),\r\n      \r\n      # g0 also for Linear/Superlinear\r\n      conditionalPanel(\r\n        condition = \"input.gType == 'linear' || input.gType == 'superlinear'\",\r\n        numericInput(\"g0_ls\", \"Set g(0) = g0 (linear/superlinear)\",\r\n                    min = 1e-6, max = 0.49, value = 0.05, step = 1e-3)\r\n      ),\r\n      \r\n      # exponent for Superlinear (p > 1)\r\n      conditionalPanel(\r\n        condition = \"input.gType == 'superlinear'\",\r\n        numericInput(\"p_super\", \"Superlinear power p (>1)\",\r\n                    min = 1.1, max = 5, value = 2, step = 0.1)\r\n      ),\r\n      \r\n      radioButtons(\"fType\", \"f(B) distribution\",\r\n                   c(\"Normal(μ, σ)\" = \"normal\",\r\n                     \"Uniform[a, b]\" = \"uniform\",\r\n                     \"Polarized\" = \"polarized\",\r\n                     \"Superpolar\" = \"superpol\")),\r\n      \r\n      conditionalPanel(\r\n        condition = \"input.fType == 'normal'\",\r\n        numericInput(\"mu\", \"μ (mean)\", value = 12, step = 0.1),\r\n        numericInput(\"sd\", \"σ (sd)\", value = 30, min = 1e-6, step = 0.1)\r\n      ),\r\n      conditionalPanel(\r\n        condition = \"input.fType == 'uniform'\",\r\n        numericInput(\"umin\", \"a (min)\", value = 0, step = 0.1),\r\n        numericInput(\"umax\", \"b (max)\", value = 100, step = 0.1)\r\n      ),\r\n      conditionalPanel(\r\n        condition = \"input.fType == 'polarized'\",\r\n        numericInput(\"w_mix\", \"Weight on component 1 (w)\", min = 0.01, max = 0.99, value = 0.5, step = 0.01),\r\n        numericInput(\"mu1\", \"μ1 (mean 1)\", value = -20, step = 0.1),\r\n        numericInput(\"sd1\", \"σ1 (sd 1)\",  value = 12,  min = 1e-6, step = 0.1),\r\n        numericInput(\"mu2\", \"μ2 (mean 2)\", value = 20,  step = 0.1),\r\n        numericInput(\"sd2\", \"σ2 (sd 2)\",  value = 12,  min = 1e-6, step = 0.1)\r\n      ),\r\n      conditionalPanel(\r\n        condition = \"input.fType == 'superpol'\",\r\n        numericInput(\"q_a\", \"a (min)\", value = 0, step = 0.1),\r\n        numericInput(\"q_b\", \"b (max)\", value = 10, step = 0.1),\r\n        helpText(\"Quadratic shape: w(x) = α + β (x - m) + γ (x - m)^2, with m = (a+b)/2.\"),\r\n        numericInput(\"q_alpha\", \"α (constant term)\", value = 1, step = 0.1),\r\n        numericInput(\"q_beta\",  \"β (linear term)\",   value = 0, step = 0.1),\r\n        numericInput(\"q_gamma\", \"γ (quadratic term)\",value = 0.06, step = 0.1)\r\n      ),\r\n      \r\n      hr(),\r\n      h4(\"P range for Q(P)\"),\r\n      # Enforce P > 0\r\n      numericInput(\"Pmin\", \"P min (> 0)\", value = 0.45, min = 1e-6, step = 0.1),\r\n      numericInput(\"Pmax\", \"P max\", value = 0.58, min = 0.2, step = 0.5),\r\n      sliderInput(\"nP\", \"Resolution (# P points)\", min = 50, max = 800, value = 100, step = 10),\r\n      \r\n      hr(),\r\n      helpText(\"Notes:\",\r\n               \"• g is auto-calibrated so it is ~1 at Q=N (Olsonian) or Q=T (Lumpy).\",\r\n               \"• Logistic also matches g(0)=g0.\",\r\n               \"• Solver respects domain: Olsonian 0<Q<N; Lumpy 0<Q<T.\")\r\n    ),\r\n    mainPanel(\r\n      tabsetPanel(\r\n        tabPanel(\"Q(P) & Backlash Diagnostic\",\r\n                 plotOutput(\"qp_plot\", height = 300),\r\n                 plotOutput(\"SP_plot\", height = 300),\r\n                 verbatimTextOutput(\"S_diag\"),\r\n                 verbatimTextOutput(\"param_snapshot\")),\r\n        tabPanel(\"g(Q), ρ′(Q), Elasticity\",\r\n                 plotOutput(\"g_plot\", height = 260),\r\n                 plotOutput(\"rhoPrime_plot\", height = 260),\r\n                 plotOutput(\"elasticity_plot\", height = 260)),\r\n        tabPanel(\"f(B) distribution\",\r\n                 plotOutput(\"f_plot\", height = 360),\r\n                 plotOutput(\"BQ_plot\", height = 360)),\r\n        tabPanel(\"Diagnostics\",\r\n                 sliderInput(\"P_check\", \"Choose P for diagnostics\",\r\n                             min = 0.1, max = 5, value = 1, step = 0.1),\r\n                 verbatimTextOutput(\"point_diag\"),     # equilibrium Q*, B*, residual\r\n                 verbatimTextOutput(\"endpoint_checks\") # existing near-boundary table\r\n        )\r\n      )\r\n    )\r\n  )\r\n)\r\n\r\nserver <- function(input, output, session) {\r\n  tiny <- 1e-12\r\n  clip01 <- function(x) pmin(pmax(x, 0), 1)\r\n  \r\n  # Keep Pmax >= Pmin and P_check within range\r\n  observe({\r\n    if (input$Pmax <= input$Pmin) {\r\n      updateNumericInput(session, \"Pmax\", value = input$Pmin + 0.1)\r\n    }\r\n    updateSliderInput(session, \"P_check\",\r\n                      min = input$Pmin, max = input$Pmax,\r\n                      value = min(max(input$P_check, input$Pmin), input$Pmax))\r\n  })\r\n  \r\n  Q_anchor <- reactive({\r\n    if (input$rhoType == \"olsonian\") max(input$N, tiny) else max(input$T, tiny)\r\n  })\r\n  \r\n  gg <- reactive({\r\n    Qa  <- Q_anchor()\r\n    eps <- input$eps\r\n    tiny <- 1e-12\r\n    \r\n    if (input$gType == \"logistic\") {\r\n      g0 <- min(max(input$g0, 1e-12), 0.499999)\r\n      num <- log((1 - g0) / g0) - log(eps / (1 - eps))\r\n      k   <- max(num / Qa, tiny)\r\n      q0  <- log((1 - g0) / g0) / k\r\n      gfun  <- function(q) 1 / (1 + exp(-k * (q - q0)))\r\n      gpfun <- function(q) { gq <- gfun(q); k * gq * (1 - gq) }\r\n      return(list(type=\"logistic\", g=gfun, gp=gpfun, k=k, q0=q0))\r\n    }\r\n    \r\n    if (input$gType == \"exponential\") {\r\n      k <- max(log(1/eps) / Qa, tiny)\r\n      gfun  <- function(q) 1 - exp(-k * pmax(q, 0))\r\n      gpfun <- function(q) k * exp(-k * pmax(q, 0))\r\n      return(list(type=\"exponential\", g=gfun, gp=gpfun, k=k, q0=0))\r\n    }\r\n    \r\n    # ----- Linear & Superlinear (calibrated to g(Qa) = 1 - eps) -----\r\n    g0_ls <- min(max(input$g0_ls, 1e-12), 1 - eps - 1e-12)  # keep < 1 - eps\r\n    A     <- (1 - eps) - g0_ls                              # amplitude to hit 1 - eps at Qa\r\n    \r\n    if (input$gType == \"linear\") {\r\n      # g(q) = g0_ls + A * (q / Qa)\r\n      gfun  <- function(q) g0_ls + A * (pmax(q, 0) / Qa)\r\n      gpfun <- function(q) rep(A / Qa, length(q))\r\n      return(list(type=\"linear\", g=gfun, gp=gpfun, g0=g0_ls, A=A, Qa=Qa))\r\n    }\r\n    \r\n    if (input$gType == \"superlinear\") {\r\n      p <- max(input$p_super, 1 + 1e-6)  # ensure > 1\r\n      # g(q) = g0_ls + A * (q / Qa)^p\r\n      gfun  <- function(q) g0_ls + A * (pmax(q, 0) / Qa)^p\r\n      gpfun <- function(q) {\r\n        x <- pmax(q, 0) / Qa\r\n        A * p * (x^(p - 1)) / Qa\r\n      }\r\n      return(list(type=\"superlinear\", g=gfun, gp=gpfun, g0=g0_ls, A=A, p=p, Qa=Qa))\r\n    }\r\n  })\r\n  \r\n  rhoPieces <- reactive({\r\n    g  <- gg()$g\r\n    gp <- gg()$gp\r\n    Tval <- input$T\r\n    \r\n    if (input$rhoType == \"olsonian\") {\r\n      rho  <- function(q) {\r\n        gq <- pmax(g(q), tiny)\r\n        q / gq\r\n      }\r\n      rhop <- function(q) {\r\n        gq  <- pmax(g(q), tiny)\r\n        gpq <- gp(q)\r\n        (gq - q * gpq) / (gq^2)\r\n      }\r\n      upper <- function() input$N\r\n    } else {\r\n      rho  <- function(q) {\r\n        gq <- pmax(g(q), tiny)\r\n        (Tval - q) / gq\r\n      }\r\n      rhop <- function(q) {\r\n        gq  <- pmax(g(q), tiny)\r\n        gpq <- gp(q)\r\n        -(gq + (Tval - q) * gpq) / (gq^2)\r\n      }\r\n      upper <- function() input$T\r\n    }\r\n    list(rho=rho, rhop=rhop, upper=upper)\r\n  })\r\n  \r\n  f_and_F <- reactive({\r\n    clip01 <- function(x) pmin(pmax(x, 0), 1)\r\n    finite <- function(x, fallback) { x <- suppressWarnings(as.numeric(x)); if (!is.finite(x)) fallback else x }\r\n    \r\n    if (input$fType == \"normal\") {\r\n      mu <- finite(input$mu, 0)\r\n      sd <- finite(input$sd, 1)\r\n      if (sd <= 0) sd <- 1\r\n      f <- function(x) dnorm(x, mean = mu, sd = sd)\r\n      F <- function(x) pnorm(x, mean = mu, sd = sd)\r\n      support <- function() c(mu - 4*sd, mu + 4*sd)\r\n      return(list(pdf = f, cdf = F, support = support))\r\n    }\r\n    \r\n    if (input$fType == \"uniform\") {\r\n      a <- finite(input$umin, 0)\r\n      b <- finite(input$umax, 1)\r\n      if (b <= a) b <- a + 1e-6\r\n      f <- function(x) ifelse(x >= a & x <= b, 1/(b-a), 0)\r\n      F <- function(x) clip01((x - a) / (b - a))\r\n      support <- function() c(a, b)\r\n      return(list(pdf = f, cdf = F, support = support))\r\n    }\r\n    \r\n    if (input$fType == \"polarized\") {\r\n      w  <- min(max(finite(input$w_mix, 0.5), 1e-6), 1-1e-6)\r\n      m1 <- finite(input$mu1, -1)\r\n      s1 <- max(finite(input$sd1, 1), 1e-6)\r\n      m2 <- finite(input$mu2,  1)\r\n      s2 <- max(finite(input$sd2, 1), 1e-6)\r\n      \r\n      f <- function(x) w * dnorm(x, m1, s1) + (1 - w) * dnorm(x, m2, s2)\r\n      F <- function(x) w * pnorm(x, m1, s1) + (1 - w) * pnorm(x, m2, s2)\r\n      \r\n      # cover both modes ± 4σ for each component\r\n      lo <- min(m1 - 4*s1, m2 - 4*s2)\r\n      hi <- max(m1 + 4*s1, m2 + 4*s2)\r\n      support <- function() c(lo, hi)\r\n      \r\n      return(list(pdf = f, cdf = F, support = support))\r\n    }\r\n    \r\n    if (input$fType == \"superpol\") {\r\n      finite <- function(x, fb) { x <- suppressWarnings(as.numeric(x)); if (is.finite(x)) x else fb }\r\n      \r\n      a <- finite(input$q_a, 0)\r\n      b <- finite(input$q_b, 1)\r\n      if (!is.finite(a)) a <- 0\r\n      if (!is.finite(b) || b <= a) b <- a + 1e-6\r\n      \r\n      alpha <- finite(input$q_alpha, 1)\r\n      beta  <- finite(input$q_beta,  0)\r\n      gamma <- finite(input$q_gamma, 0)\r\n      \r\n      # Center at midpoint for numerical stability\r\n      m  <- 0.5 * (a + b)\r\n      nx <- 2048L                      # dense grid for smooth CDF\r\n      xg <- seq(a, b, length.out = nx)\r\n      w  <- alpha + beta * (xg - m) + gamma * (xg - m)^2\r\n      w  <- pmax(w, 0)                 # ensure nonnegative \"weight\"\r\n      \r\n      # If the quadratic is nonpositive everywhere, fall back to uniform on [a,b]\r\n      if (all(w <= 0)) {\r\n        pdf_vals <- rep(1 / (b - a), nx)\r\n        cdf_vals <- (xg - a) / (b - a)\r\n      } else {\r\n        dx       <- (b - a) / (nx - 1)\r\n        Z        <- sum(w) * dx\r\n        if (!is.finite(Z) || Z <= 0) Z <- 1 # safety\r\n        pdf_vals <- w / Z\r\n        \r\n        # cumulative via trapezoid rule, capped to [0,1]\r\n        cdf_vals <- cumsum(c(0, head(pdf_vals, -1))) * dx\r\n        # small correction to reach 1 exactly at the end\r\n        cdf_vals <- pmin(pmax(cdf_vals, 0), 1)\r\n        cdf_vals[length(cdf_vals)] <- 1\r\n      }\r\n      \r\n      # Fast interpolators for pdf and cdf\r\n      f_pdf <- approxfun(xg, pdf_vals, yleft = 0, yright = 0, ties = \"ordered\")\r\n      F_cdf <- approxfun(xg, cdf_vals, yleft = 0, yright = 1, ties = \"ordered\")\r\n      \r\n      support <- function() c(a, b)\r\n      return(list(pdf = f_pdf, cdf = F_cdf, support = support))\r\n    }\r\n  })\r\n  \r\n  # h(Q;P) residual\r\n  h_fun <- reactive({\r\n    N <- input$N; d <- input$d\r\n    F <- f_and_F()$cdf\r\n    rho <- rhoPieces()$rho\r\n    function(q, P) {\r\n      Bstar <- (P - d) * rho(q)\r\n      q - N * (1 - F(Bstar))\r\n    }\r\n  })\r\n  \r\n  # Domain restricted solver: Olsonian (0,Q,N) ; Lumpy (0,Q,T)\r\n  solve_Q_for_P <- function(P) {\r\n    N <- input$N\r\n    upper <- rhoPieces()$upper()\r\n    epsQ <- min(1e-8 * max(N, upper, 1), 1e-6)\r\n    \r\n    lo <- epsQ\r\n    hi <- max(upper - epsQ, lo + epsQ)  # ensure lo < hi\r\n    h <- h_fun()\r\n    \r\n    # Try to bracket strictly inside (lo, hi)\r\n    Qgrid <- seq(lo, hi, length.out = 601)\r\n    hv <- sapply(Qgrid, function(q) h(q, P))\r\n    idx <- which(diff(sign(hv)) != 0)\r\n    \r\n    if (length(idx) >= 1) {\r\n      loB <- Qgrid[idx[1]]\r\n      hiB <- Qgrid[idx[1] + 1]\r\n      out <- try(uniroot(function(q) h(q, P), lower = loB, upper = hiB), silent = TRUE)\r\n      if (!inherits(out, \"try-error\")) return(out$root)\r\n    }\r\n    \r\n    # No sign change: clamp to nearest interior boundary point\r\n    if (abs(h(lo, P)) < abs(h(hi, P))) lo else hi\r\n  }\r\n  \r\n  # Find all Q roots of h(Q; P) = Q - N*(1 - F((P-d)*rho(Q))) for a given P\r\n  all_Q_for_P <- function(P, n_scan = 400) {\r\n    N <- input$N\r\n    upperQ <- if (input$rhoType == \"olsonian\") input$N else input$T\r\n    epsQ <- max(upperQ * 1e-8, 1e-10)\r\n    \r\n    rho <- rhoPieces()$rho\r\n    F   <- f_and_F()$cdf\r\n    \r\n    h <- function(Q) Q - N * (1 - F((P - input$d) * rho(Q)))\r\n    \r\n    # coarse grid to find sign changes\r\n    qg <- seq(epsQ, upperQ - epsQ, length.out = n_scan)\r\n    hg <- sapply(qg, h)\r\n    \r\n    roots <- numeric(0)\r\n    for (k in 1:(length(qg) - 1)) {\r\n      y1 <- hg[k]; y2 <- hg[k + 1]\r\n      if (!is.finite(y1) || !is.finite(y2)) next\r\n      if (y1 == 0) { roots <- c(roots, qg[k]); next }\r\n      if (y1 * y2 < 0) {\r\n        # refine with uniroot in the bracket\r\n        r <- try(uniroot(h, lower = qg[k], upper = qg[k + 1]), silent = TRUE)\r\n        if (!inherits(r, \"try-error\")) roots <- c(roots, r$root)\r\n      }\r\n    }\r\n    sort(unique(roots))\r\n  }\r\n  \r\n  qp_data <- reactive({\r\n    Pseq <- seq(max(input$Pmin, 1e-9), input$Pmax, length.out = input$nP)\r\n    N <- input$N; d <- input$d\r\n    rho  <- rhoPieces()$rho\r\n    rhop <- rhoPieces()$rhop\r\n    Fcdf <- f_and_F()$cdf\r\n    fpdf <- f_and_F()$pdf\r\n    \r\n    Qs <- vapply(Pseq, solve_Q_for_P, numeric(1))\r\n    Bstar <- (Pseq - d) * rho(Qs)\r\n    Sp <- N * fpdf(Bstar) * (Pseq - d) * rhop(Qs)\r\n    \r\n    df <- data.frame(P = Pseq, Q = Qs, Bstar = Bstar, S = Sp)\r\n    \r\n    df$S_theory <- NA_real_\r\n    \r\n    if (input$rhoType == \"olsonian\" && input$gType == \"superlinear\" && input$fType == \"uniform\") {\r\n      N  <- input$N\r\n      a  <- input$umin; b <- input$umax\r\n      g0 <- input$g0_ls\r\n      eps <- input$eps\r\n      p   <- input$p_super\r\n      A   <- (1 - eps) - g0\r\n      \r\n      x <- pmin(pmax(df$Q / N, 1e-12), 1 - 1e-12)         # x = Q/N\r\n      gQ <- g0 + A * (x^p)                                 # g(Q)\r\n      # Closed-form S(x) for uniform[a,b] with superlinear g:\r\n      # S(x) = (1 - x) * [ 1/x - (A p x^(p-1)) / (g0 + A x^p) ]\r\n      df$S_theory <- (1 - x) * (1/x - (A * p * x^(p - 1)) / gQ)\r\n      \r\n      # Optional: record whether B* lies inside support (it should; else f(B*)=0)\r\n      df$B_inside <- (df$Bstar >= a) & (df$Bstar <= b)\r\n    }\r\n    \r\n    df\r\n  })\r\n  \r\n  qp_multi <- reactive({\r\n    Pseq <- seq(input$Pmin, input$Pmax, length.out = input$nP)\r\n    rho <- rhoPieces()$rho\r\n    rhop <- rhoPieces()$rhop\r\n    pdf <- f_and_F()$pdf\r\n    \r\n    out <- lapply(Pseq, function(P) {\r\n      Qs <- all_Q_for_P(P)\r\n      if (length(Qs) == 0) return(NULL)\r\n      B  <- (P - input$d) * rho(Qs)\r\n      S  <- input$N * pdf(B) * (P - input$d) * rhop(Qs)\r\n      data.frame(P = P, Q = Qs, Bstar = B, S = S)\r\n    })\r\n    do.call(rbind, out)\r\n  })\r\n  \r\n  # Intervals of P where S(P) < -1, computed from qp_data()\r\n  S_intervals <- reactive({\r\n    df <- qp_data()\r\n    valid <- which(!is.na(df$S))\r\n    if (length(valid) == 0) return(data.frame(Plo = numeric(0), Phi = numeric(0)))\r\n    \r\n    idx <- which(df$S < -1 & !is.na(df$S))\r\n    if (length(idx) == 0) return(data.frame(Plo = numeric(0), Phi = numeric(0)))\r\n    \r\n    # group contiguous indices into runs\r\n    runs <- split(idx, cumsum(c(1, diff(idx) != 1)))\r\n    out <- do.call(rbind, lapply(runs, function(idxs) {\r\n      data.frame(Plo = min(df$P[idxs]), Phi = max(df$P[idxs]))\r\n    }))\r\n    rownames(out) <- NULL\r\n    out\r\n  })\r\n  \r\n  # ----- Plots / Outputs -----\r\n  \r\n  # ---- Q(P) plot with multi-root overlay (no warnings) ----\r\n  output$qp_plot <- renderPlot({\r\n    df1 <- qp_data()      # your original single-branch curve\r\n    dfm <- qp_multi()     # all equilibria across P (possibly 0/1/2+ per P)\r\n    \r\n    ggplot() +\r\n      # gray points: all equilibria at each P (no \"group\" needed)\r\n      { if (!is.null(dfm) && nrow(dfm) > 0)\r\n        geom_point(data = dfm, aes(P, Q),\r\n                   color = \"grey50\", alpha = 0.7, size = 0.9) } +\r\n      # tracked branch as a solid black line\r\n      { if (!is.null(df1) && nrow(df1) > 1)\r\n        geom_line(data = df1, aes(P, Q), color = \"black\", linewidth = 1.1) } +\r\n      labs(title = \"Equilibria Q(P): black = tracked branch, grey = all roots\",\r\n           x = \"P\", y = \"Q\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$SP_plot <- renderPlot({\r\n    df1 <- qp_data()    # tracked branch: columns include P, S\r\n    dfm <- qp_multi()   # all equilibria across P: columns include P, S\r\n    \r\n    # Min across branches at each P (envelope)\r\n    agg <- NULL\r\n    if (!is.null(dfm) && nrow(dfm) > 0) {\r\n      agg <- aggregate(S ~ P, data = dfm, FUN = min)\r\n      agg <- agg[order(agg$P), , drop = FALSE]\r\n    }\r\n    \r\n    ggplot() +\r\n      # All equilibria (possibly 1 or more per P): grey points\r\n      { if (!is.null(dfm) && nrow(dfm) > 0)\r\n        geom_point(data = dfm, aes(x = P, y = S),\r\n                   color = \"grey50\", alpha = 0.7, size = 0.9) } +\r\n      # Tracked branch from qp_data(): black line\r\n      { if (!is.null(df1) && nrow(df1) > 1)\r\n        geom_line(data = df1, aes(x = P, y = S),\r\n                  color = \"black\", linewidth = 1.1) } +\r\n      # Envelope: min S across branches at each P (red dashed)\r\n      { if (!is.null(agg) && nrow(agg) > 1)\r\n        geom_line(data = agg, aes(x = P, y = S),\r\n                  color = \"red\", linewidth = 1, linetype = \"dashed\") } +\r\n      # Backlash threshold\r\n      geom_hline(yintercept = -1, linetype = \"dashed\", color = \"red\") +\r\n      labs(title = \"Backlash diagnostic: S(P) across multiple equilibria\",\r\n           subtitle = \"Grey = all equilibria; Black = tracked branch; Red dashed = min across branches; S=-1 dashed\",\r\n           x = \"P\", y = \"S(P)\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$S_diag <- renderPrint({\r\n    cat(\"S(P) = N f(B*) (P - d) ρ′(Q)\\n\")\r\n    dfm <- qp_multi()\r\n    if (is.null(dfm) || nrow(dfm) == 0) {\r\n      cat(\"No equilibria found in the current P-range.\\n\"); return(invisible())\r\n    }\r\n    # For each P, take min S across branches\r\n    agg <- aggregate(S ~ P, data = dfm, FUN = min)\r\n    mS  <- min(agg$S, na.rm = TRUE); MS <- max(agg$S, na.rm = TRUE)\r\n    cat(sprintf(\"minS (across branches): %.4f   maxS: %.4f\\n\", mS, MS))\r\n    cat(\"Backlash requires S < -1\\n\")\r\n    \r\n    idx <- which(agg$S < -1)\r\n    if (length(idx) == 0) {\r\n      cat(\"\\nNo P-intervals where S < -1 across branches.\\n\")\r\n    } else {\r\n      runs <- split(idx, cumsum(c(1, diff(idx) != 1)))\r\n      cat(\"\\nP-intervals where min_branch S(P) < -1:\\n\")\r\n      for (r in runs) {\r\n        cat(sprintf(\"  [%.6f, %.6f]\\n\", min(agg$P[r]), max(agg$P[r])))\r\n      }\r\n    }\r\n  })\r\n  \r\n  output$g_plot <- renderPlot({\r\n    g <- gg()$g\r\n    Qmax <- max(input$N, input$T)\r\n    q <- seq(0, Qmax, length.out = 400)\r\n    df <- data.frame(Q=q, g = g(q))\r\n    ggplot(df, aes(Q, g)) +\r\n      geom_line(linewidth = 1) +\r\n      labs(title = \"g(Q)\", y = \"g(Q)\", x = \"Q\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$rhoPrime_plot <- renderPlot({\r\n    rhop <- rhoPieces()$rhop\r\n    Qmax <- max(input$N, input$T)\r\n    q <- seq(0, Qmax, length.out = 400)\r\n    df <- data.frame(Q=q, rhop = rhop(q))\r\n    ggplot(df, aes(Q, rhop)) +\r\n      geom_hline(yintercept = 0, linewidth = 0.4, linetype = \"dashed\") +\r\n      geom_line(linewidth = 1) +\r\n      labs(title = \"ρ′(Q)\", y = \"ρ′(Q)\", x = \"Q\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$elasticity_plot <- renderPlot({\r\n    g <- gg()$g\r\n    gp <- gg()$gp\r\n    Qmax <- max(input$N, input$T)\r\n    q <- seq(0, Qmax, length.out = 400)\r\n    gq <- pmax(g(q), tiny)\r\n    eq <- (q * gp(q)) / gq\r\n    df <- data.frame(Q=q, E=eq)\r\n    ggplot(df, aes(Q, E)) +\r\n      geom_hline(yintercept = 0, linewidth = 0.4, linetype = \"dashed\") +\r\n      geom_line(linewidth = 1) +\r\n      labs(title = \"Elasticity:  E(Q) = Q g′(Q) / g(Q)\", y = \"E(Q)\", x = \"Q\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$f_plot <- renderPlot({\r\n    distr <- f_and_F()\r\n    rng <- distr$support()\r\n    x <- seq(rng[1], rng[2], length.out = 400)\r\n    y <- distr$pdf(x)\r\n    ggplot(data.frame(x, y), aes(x, y)) +\r\n      geom_line(linewidth = 1) +\r\n      labs(title = \"f(B): PDF\", x = \"B\", y = \"f(B)\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  output$BQ_plot <- renderPlot({\r\n    # P, Q grids\r\n    Pvals <- seq(input$Pmin, input$Pmax, length.out = 120)\r\n    \r\n    upperQ <- if (input$rhoType == \"olsonian\") input$N else input$T\r\n    epsQ   <- max(upperQ * 1e-6, 1e-6)\r\n    Qvals  <- seq(epsQ, upperQ - epsQ, length.out = 120)\r\n    \r\n    rho_fun <- rhoPieces()$rho\r\n    d <- input$d\r\n    \r\n    grid <- expand.grid(P = Pvals, Q = Qvals)\r\n    grid$Bstar <- (grid$P - d) * rho_fun(grid$Q)\r\n    \r\n    # winsorize for color scale so extremes don't wash out the palette\r\n    finite_vals <- grid$Bstar[is.finite(grid$Bstar)]\r\n    qlo <- if (length(finite_vals)) quantile(finite_vals, 0.01, na.rm = TRUE) else 0\r\n    qhi <- if (length(finite_vals)) quantile(finite_vals, 0.99, na.rm = TRUE) else 1\r\n    grid$Bplot <- pmin(pmax(grid$Bstar, qlo), qhi)\r\n    \r\n    # Equilibrium locus\r\n    df_eq <- qp_data()[, c(\"P\", \"Q\")]\r\n    df_eq <- df_eq[is.finite(df_eq$P) & is.finite(df_eq$Q), , drop = FALSE]\r\n    df_eq <- df_eq[order(df_eq$P), , drop = FALSE]\r\n    \r\n    # Diagnostic point (make a 1-row data frame so it doesn't inherit the grid)\r\n    Q_star <- solve_Q_for_P(input$P_check)\r\n    df_pt <- if (is.finite(Q_star)) data.frame(P = input$P_check, Q = Q_star) else NULL\r\n    \r\n    ggplot() +\r\n      # Heatmap\r\n      geom_raster(data = grid, aes(x = P, y = Q, fill = Bplot), interpolate = TRUE) +\r\n      # Contours (use true B*, not winsorized), prevent aes inheritance\r\n      geom_contour(\r\n        data = grid,\r\n        aes(x = P, y = Q, z = Bstar),\r\n        color = \"white\", linewidth = 0.3, alpha = 0.8,\r\n        inherit.aes = FALSE\r\n      ) +\r\n      # Equilibrium locus\r\n      { if (nrow(df_eq) > 1)\r\n        geom_path(data = df_eq, aes(x = P, y = Q), color = \"red\", linewidth = 1.1,\r\n                  inherit.aes = FALSE) } +\r\n      # Diagnostic point\r\n      { if (!is.null(df_pt))\r\n        geom_point(data = df_pt, aes(x = P, y = Q), color = \"red\", size = 2,\r\n                   inherit.aes = FALSE) } +\r\n      scale_fill_viridis_c(\r\n        name = \"B* = (P - d)·ρ(Q)\",\r\n        limits = c(qlo, qhi),\r\n        oob = scales::squish\r\n      ) +\r\n      labs(title = \"B*(Q,P) heatmap with equilibrium locus\",\r\n           x = \"P\", y = \"Q\") +\r\n      theme_minimal(base_size = 13)\r\n  })\r\n  \r\n  # ----- Point diagnostics: equilibrium values at P_check -----\r\n  output$point_diag <- renderPrint({\r\n    P  <- input$P_check\r\n    d  <- input$d\r\n    N  <- input$N\r\n    rho <- rhoPieces()$rho\r\n    F   <- f_and_F()$cdf\r\n    \r\n    Q_star <- solve_Q_for_P(P)\r\n    B_star <- (P - d) * rho(Q_star)\r\n    \r\n    # Residual h(Q*; P) = Q* - N*(1 - F(B*))\r\n    h_val  <- Q_star - N * (1 - F(B_star))\r\n    \r\n    cat(\"Equilibrium (interior) at selected P:\\n\")\r\n    cat(sprintf(\"  P = %.6g\\n\", P))\r\n    cat(sprintf(\"  Q* = %.6g\\n\", Q_star))\r\n    cat(sprintf(\"  B* = (P - d) * ρ(Q*) = %.6g\\n\", B_star))\r\n    cat(sprintf(\"  Residual h(Q*;P) = Q* - N*(1 - F(B*)) = %.3e\\n\", h_val))\r\n  })\r\n  \r\n  # ----- Equilibrium endpoint diagnostics -----\r\n  \r\n  endpoint_diag <- reactive({\r\n    P <- input$P_check\r\n    N <- input$N; d <- input$d\r\n    rho <- rhoPieces()$rho\r\n    upper <- rhoPieces()$upper()\r\n    F <- f_and_F()$cdf\r\n    \r\n    epsQ <- min(1e-8 * max(N, upper, 1), 1e-6)\r\n    # Near-boundary interior points\r\n    q_lo <- epsQ\r\n    q_up <- upper - epsQ\r\n    \r\n    # Also report near T if Lumpy (since ρ(T)=0)\r\n    q_T  <- if (input$rhoType == \"lumpy\") max(min(input$T - epsQ, q_up), q_lo) else NA_real_\r\n    \r\n    h <- h_fun()\r\n    \r\n    rows <- list(\r\n      list(Point = \"Near lower bound\",  Q = q_lo, h = h(q_lo, P),\r\n           Bstar = (P - d) * rho(q_lo)),\r\n      list(Point = \"Near upper bound\",  Q = q_up, h = h(q_up, P),\r\n           Bstar = (P - d) * rho(q_up))\r\n    )\r\n    if (input$rhoType == \"lumpy\") {\r\n      rows <- append(rows, list(\r\n        list(Point = \"Near T (Lumpy)\", Q = q_T, h = h(q_T, P),\r\n             Bstar = (P - d) * rho(q_T))\r\n      ))\r\n    }\r\n    \r\n    df <- do.call(rbind, lapply(rows, as.data.frame))\r\n    df$one_minus_F <- 1 - F(df$Bstar)\r\n    df$RHS <- N * df$one_minus_F\r\n    df$Equilibrium_if_allowed <- ifelse(abs(df$h) < 1e-6, \"Yes (≈0)\", \"No\")\r\n    df\r\n  })\r\n  \r\n  # --- Theoretical checker for: rho=Olsonian, g=Superlinear, f=Uniform[a,b] ---\r\n  theory_band <- reactive({\r\n    if (!(input$rhoType == \"olsonian\" && input$gType == \"superlinear\" && input$fType == \"uniform\"))\r\n      return(NULL)\r\n    \r\n    N  <- input$N\r\n    a  <- input$umin; b <- input$umax\r\n    g0 <- input$g0_ls\r\n    eps <- input$eps\r\n    p   <- input$p_super\r\n    if (!is.finite(N) || !is.finite(a) || !is.finite(b) || !is.finite(g0) ||\r\n        !is.finite(eps) || !is.finite(p) || b <= a || g0 <= 0 || p <= 1) return(NULL)\r\n    \r\n    A <- (1 - eps) - g0\r\n    if (A <= 0) return(NULL)\r\n    \r\n    # x := Q/N\r\n    x <- seq(1e-6, 1 - 1e-6, length.out = 5000)\r\n    gQ <- g0 + A * x^p                         # g(Q) with Q/N = x\r\n    Sx <- (1 - x) * ( 1/x - (A * p * x^(p-1)) / gQ )\r\n    \r\n    # Uniform[a,b]: B* = a + (1 - x)(b - a), so P = d + (B* g(Q))/Q = d + (a + (1 - x)(b - a)) * gQ / (x * N)\r\n    P_of_x <- input$d + (a + (1 - x) * (b - a)) * gQ / (x * N)\r\n    \r\n    # find S(x) < -1 segments and map to P\r\n    idx <- which(Sx < -1)\r\n    if (length(idx) == 0) {\r\n      return(list(has_band = FALSE, minS = min(Sx, na.rm = TRUE)))\r\n    }\r\n    runs <- split(idx, cumsum(c(1, diff(idx) != 1)))\r\n    band <- do.call(rbind, lapply(runs, function(idxs) {\r\n      data.frame(Plo = min(P_of_x[idxs], na.rm = TRUE), Phi = max(P_of_x[idxs], na.rm = TRUE))\r\n    }))\r\n    list(\r\n      has_band = TRUE,\r\n      minS = min(Sx, na.rm = TRUE),\r\n      band = band,\r\n      P_at_min = P_of_x[which.min(Sx)],\r\n      x_at_min = x[which.min(Sx)]\r\n    )\r\n  })\r\n  \r\n  numeric_band <- reactive({\r\n    df <- qp_data()\r\n    if (!all(c(\"P\",\"S\") %in% names(df))) return(NULL)\r\n    idx <- which(df$S < -1 & is.finite(df$S))\r\n    if (length(idx) == 0) return(list(has_band = FALSE, minS = min(df$S, na.rm = TRUE)))\r\n    runs <- split(idx, cumsum(c(1, diff(idx) != 1)))\r\n    band <- do.call(rbind, lapply(runs, function(idxs) {\r\n      data.frame(Plo = min(df$P[idxs], na.rm = TRUE), Phi = max(df$P[idxs], na.rm = TRUE))\r\n    }))\r\n    list(has_band = TRUE, minS = min(df$S, na.rm = TRUE), band = band)\r\n  })\r\n  \r\n  output$param_snapshot <- renderPrint({\r\n    cat(\"Snapshot of current parameters (for sanity):\\n\")\r\n    cat(sprintf(\"  rhoType=%s | gType=%s | fType=%s\\n\",\r\n                input$rhoType, input$gType, input$fType))\r\n    cat(sprintf(\"  N=%g  d=%g\\n\", input$N, input$d))\r\n    if (input$gType == \"superlinear\") {\r\n      cat(sprintf(\"  g0_ls=%g  p_super=%g  eps=%g  (so g(N)=1-eps)\\n\",\r\n                  input$g0_ls, input$p_super, input$eps))\r\n    }\r\n    if (input$fType == \"uniform\") {\r\n      cat(sprintf(\"  Uniform [a,b]=[%g, %g]\\n\", input$umin, input$umax))\r\n    }\r\n    cat(sprintf(\"  P-range = [%.6f, %.6f]  (resolution nP=%d)\\n\",\r\n                input$Pmin, input$Pmax, input$nP))\r\n  })\r\n  \r\n  output$endpoint_checks <- renderPrint({\r\n    df <- endpoint_diag()\r\n    cat(\"Residual h(Q;P) = Q - N * (1 - F((P-d)ρ(Q))) at interior near-boundaries:\\n\\n\")\r\n    print(within(df, {\r\n      h <- round(h, 6); Q <- signif(Q, 6); Bstar <- signif(Bstar, 6); RHS <- signif(RHS, 6)\r\n      one_minus_F <- signif(one_minus_F, 6)\r\n    }), row.names = FALSE)\r\n    cat(\"\\nInterpretation: a zero residual would mean a boundary equilibrium (if boundaries were allowed).\",\r\n        \"\\n(We enforce 0<Q<N for Olsonian, 0<Q<T for Lumpy.)\\n\")\r\n  })\r\n}\r\n\r\nshinyApp(ui, server)\r\n","type":"text"}]
